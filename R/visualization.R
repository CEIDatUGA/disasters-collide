# Dependencies: 
# install.packages("here")
# install.packages("tidyverse")
# install.packages("sf")
# install.packages("classInt")
# install.packages("stringr")
# install.packages("cowplot")
# install.packages("gridGraphics")

library(here)
library(tidyverse)
library(sf)
library(classInt) # classIntervals, findCols
library(stringr) # string substitutions
library(cowplot)
library(gridGraphics)

# hcl2hex --------------------------------------------------------------

# hcl2hex function from 'datacolor' R package by Eric Marty
# https://github.com/allopole/datacolor 
hcl2hex <- function (hcl = NULL, H = NULL, C = NULL, L = NULL) 
{
  if (!is.null(hcl)) {
    palette <- grDevices::hcl(h = hcl$H, c = hcl$C, l = hcl$L, 
                              fixup = FALSE)
  }
  else {
    palette <- grDevices::hcl(h = H, c = C, l = L, fixup = FALSE)
  }
  return(palette)
}

# bivariateClass --------------------------------------------------------------

# Takes objects of class classIntervals" generated by classInt::classIntervals()
# Generates a joint class for use with a bivariate color scale
bivariateClass <- function (breaks1, breaks2) {
  if (!(length(breaks1[[2]])==length(breaks2[[2]]))) {
    stop("breaks1 and breaks2 must have the same number of breaks.")
  }
  n <- length(breaks1[[2]])-1
  a <- classInt::findCols(breaks1) # numeric class
  b <- classInt::findCols(breaks2) # numeric class
  j <- tidyr::replace_na(a,0) + tidyr::replace_na(n*(b-1),0)
  j <- j %>% na_if(0)
  j
}

# bivariateColor --------------------------------------------------------------

# Takes objects of class classIntervals" generated by classInt::classIntervals()
bivariateColor <- function(nbins=9) {
  n <- nbins^(1/2)
  hue.1 <- 230 # cyan
  hue.2 <- 360 # red
  hue.min <- min(hue.1, hue.2)
  hue.range <- max(hue.1, hue.2)-hue.min
  
  c <- seq(0,45,length.out=n)
  l <- seq(100,55,length.out=n)
  
  var1 <- var2 <- seq(0,1,length.out=n)
  
  # Scale 1
  scale.1.hcl <- data.frame(H =  hue.1, C = c, L = l)

  # Scale 2
  scale.2.hcl <- data.frame(H =  hue.2, C = c, L = l)

  
  scale.bivariate <- expand_grid(v1 = var1, v2 = var2) %>%
    mutate(class.v1 = as.integer(factor(v1)),
           class.v2 = as.integer(factor(v2)),
           weightsum = v1+v2,
           weight.v1 = ifelse(weightsum == 0, .5, v1/weightsum),
           weight.v2 = ifelse(weightsum == 0, .5, v2/weightsum),
           class.joint = class.v1 + n*(class.v2-1),
           # H = hue.min+((v1*hue.range+v2*hue.range)*.5),
           H = weight.v1*hue.1+weight.v2*hue.2,
           # C = 100-((100-scale.1.hcl$C[class.v1])*(100-scale.1.hcl$C[class.v1])*.01),
           C = weight.v1*scale.1.hcl$C[class.v1]+weight.v2*scale.2.hcl$C[class.v2],
           L = (scale.1.hcl$L[class.v1])*(scale.2.hcl$L[class.v2])*.01
    ) %>% 
    arrange(class.v2,class.v1)
  
  scale.bivariate$rgb <- scale.bivariate %>% hcl2hex()
  return(scale.bivariate$rgb)
}

# colormatrix --------------------------------------------------------------
# creates a legend for bivariate color palette

colormatrix <- function (colors, labels = FALSE, borders = NA, 
                         xbreaks=NULL,
                         ybreaks=NULL,
                         xlab="", ylab="") 
{
  n <- length(colors)
  ncol <- ceiling(sqrt(length(colors)))
  nrow <- ceiling(n/ncol)
  if(is.null(xbreaks)){
    xbreaks <- (0:ncol)/ncol
  }
  if(is.null(xbreaks)){
    ybreaks <- (0:nrow)/nrow
  }
  
  colors.df <- tibble(color = colors) %>% 
    mutate(x = rep.int((1:ncol)-1,nrow),
           y = rep((1:nrow)-1,each=ncol)
    )
  
  colors.df %>% ggplot() +  
    geom_rect(aes(xmin = x, xmax = x+1, ymin = y, ymax = y+1),
              fill = colors.df$color) +
    theme_minimal() +
    coord_fixed() +
    # theme_minimal(base_size = 20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_blank()
    ) +
    scale_x_continuous(name = xlab, breaks = 0:ncol, labels=xbreaks) +
    scale_y_continuous(name = ylab, breaks = 0:nrow, labels=ybreaks)
}


# bivariateChoropleth -----------------------------------------------------

bivariateChoropleth <- function(data, 
                                x, y, 
                                nbins = 3, # bins per variable
                                x.breaks = NULL, y.breaks = NULL, 
                                x.label = NULL, y.label = NULL,
                                overlay = NULL,
                                colorfunction = bivariateColor){
  
  #x.breaks
  if(is.null(x.breaks)) {
    x.breaks <- data %>% pull(x) %>%  
      classInt::classIntervals(n=nbins, style='equal') # equal breaks across range of data
    x.ticks <- signif(x.breaks$brks, digits = 3)
  }else{
    if(x.breaks=="log") {
      x.breaks <- data %>% pull(x) %>% log() %>% na_if(-Inf) %>%
        classInt::classIntervals(n=nbins, style='equal') # equal breaks across range of data
      x.ticks <- signif(exp(x.breaks$brks), digits = 3)
    }
  }
  
  #y.breaks
  if(is.null(y.breaks)) {
    y.breaks <- data %>% pull(y) %>%  
      classInt::classIntervals(n=nbins, style='equal') # equal breaks across range of data
    y.ticks <- signif(y.breaks$brks, digits = 3)
  }else{
    if(y.breaks=="log") {
      y.breaks <- data %>% pull(y) %>% log() %>% na_if(-Inf) %>%
        classInt::classIntervals(n=nbins, style='equal') # equal breaks across range of data
      y.ticks <- signif(exp(y.breaks$brks), digits = 3)
    }
  }
  
  #joint class
  data$class.joint <- bivariateClass(x.breaks,y.breaks)
  
  # map
  map <- data %>% 
    ggplot() +
    geom_sf(aes(fill = factor(class.joint, levels = as.character(1:nbins^2))),
            color = NA,
            linetype = 1
            ) +
    scale_fill_manual(values = bivariateColor(nbins^2),
                      aesthetics = "fill",
                      # breaks = waiver(),
                      na.value = "grey50"
    )
  # tracks overlay
  if(!is.null(overlay)){
    map <- map +
      geom_sf(data = overlay, 
              size = .5, alpha = .35) +
      coord_sf(xlim = bounding_box[c('xmin','xmax')], 
               ylim = bounding_box[c('ymin','ymax')], 
               expand = FALSE)
  }  
  # map styling
  map <- map +
    theme_minimal() +
    theme(legend.position="none",
          text = element_text(size = 20),
          panel.grid.major = element_line(size = 0.25, linetype = 'solid',
                                          colour = "lightblue"))
  
  # legend
  leg <- colormatrix(colorfunction(nbins^2),
                     xlab=x.label, ylab=y.label,
                     xbreaks = x.ticks, ybreaks = y.ticks
  ) 
  
  fontsize <- 12
  # legend
  cowplot::plot_grid(map + 
                       theme(text = element_text(size = fontsize)), 
                     leg + 
                       theme(text = element_text(size = 10),
                             axis.text.x = element_text(angle = 90, vjust = .5)),
                     rel_widths = c(.8,.2),
                     scale = c(1, .9))
}
